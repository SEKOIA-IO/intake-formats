name: Check intakes

# Controls when the action will run.
on:
  # Triggers the workflow on push or pull request events but only for the main branch
  push:
    branches: [main]
  pull_request:
    branches: [main]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

defaults:
  run:
    working-directory: utils

jobs:
  check_intakes:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2
        with:
          fetch-depth: 0

      - name: Set up Python 3.10
        uses: actions/setup-python@v3
        id: setup-python
        with:
          python-version: "3.10"

      - name: Install Poetry
        run: |
          pip install poetry
          poetry config virtualenvs.in-project true

      - name: Install dependencies
        run: |
          poetry install --only main

      - name: Checking modules & formats
        id: checks
        run: |
          poetry run python checks --changes --json --ignore_event_fieldset_errors --ignore_missing_parsers --ignore_missing_tests --ignore_empty_descriptions > /tmp/checks_output.json
        continue-on-error: true

      - name: Post PR comment
        if: steps.checks.outcome == 'failure' && github.event_name == 'pull_request'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const fileContent = fs.readFileSync('/tmp/checks_output.json', 'utf8');
            const MAX_COMMENT_LENGTH = 65000;
            let body = '### :warning: Intake Format Checks Failed\n\n';

            try {
                const results = JSON.parse(fileContent);

                if (results.modules.length > 0) {
                    body += '#### Module Errors\n\n';
                    for (const module of results.modules) {
                        body += `*   **${module.path}**\n`;
                        for (const error of module.errors) {
                            body += `    *   ${error.message}`;
                            body += ` - code: \`${error.code}\``;
                            body += ` - file: \`${error.file_path}\``;
                            if (error.error) {
                                body += ` - ${error.error}`;
                            }
                            body += '\n';
                        }
                    }
                }

                if (results.formats.length > 0) {
                    body += '\n#### Format Errors\n\n';
                    for (const format of results.formats) {
                        body += `*   **${format.path}**\n`;
                        for (const error of format.errors) {
                            body += `    *   ${error.message}`;
                            body += ` - code: \`${error.code}\``;
                            body += ` - file: \`${error.file_path}\``;
                            if (error.error) {
                                body += ` - ${error.error}`;
                            }
                            if (error.data_source) {
                              body += ` - data source: \`${error.data_source}\``;
                            }
                            if (error.field_name) {
                              body += ` - field: \`${error.field_name}\``;
                            }
                            body += '\n';
                        }
                    }
                }
            } catch (e) {
                body += 'An error occurred while parsing the check results.\n\n';
                body += '<details>\n<summary>Raw output</summary>\n\n';
                body += '```\n' + fileContent + '\n```\n\n</details>';
            }

            if (body.length > MAX_COMMENT_LENGTH) {
                // Truncate at the last newline before the limit to avoid cutting in the middle of a list item
                let truncated = body.substring(0, MAX_COMMENT_LENGTH - 100);
                const lastNewline = truncated.lastIndexOf('\n');
                if (lastNewline > 0) {
                    truncated = truncated.substring(0, lastNewline);
                }
                // Count occurrences of code block markers
                const codeBlockMatches = (truncated.match(/```/g) || []).length;
                // If odd number, we have an unclosed code block, so close it
                if (codeBlockMatches % 2 !== 0) {
                    truncated += '\n```';
                }
                body = truncated + '\n\n... (comment truncated due to length)';
            }

            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

      - name: Fail workflow if checks failed
        if: steps.checks.outcome == 'failure'
        run: exit 1
