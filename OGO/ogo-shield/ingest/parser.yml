name: ogo-shield
pipeline:
  - name: parser
    external:
      name: json.parse-json
      properties:
        input_field: "{{original.message}}"
        output_field: message

  - name: parsed_date
    external:
      name: date.parse
      properties:
        input_field: "{{parser.message.timestamp}}"
        output_field: datetime
        format: timestamp

  - name: set_ecs_fields

  - name: set_ogo_fields

stages:
  set_ecs_fields:
    actions:
      - set:
          url.original: "{{ parser.message.requestUrl }}"
          rule.uuid: "{{ parser.message.ogo.driveUid }}"
          rule.name: "{{ parser.message.ogo.driveLabel }}"
          server.ip: "{{ parser.message.serviceAddr }}"
          source.ip: "{{ parser.message.clientIP }}"
          "@timestamp": "{{ parsed_date.datetime }}"
          event.type: '["connection", "access"]'
          tls.cipher: "{{ parser.message.tlsCipher }}"
          tls.version: "{{ parser.message.tlsVersion }}"
          event.action: "{{ parser.message.ogo.appliedAction }}"
          event.module: ogo.shield.waf
          event.dataset: ogo-shield
          observer.type: firewall
          client.address: "{{ parser.message.clientIP }}"
          event.category:
            - network
          event.duration: "{{ parser.message.responseTimeMs }}"
          server.address: "{{ parser.message.serviceAddr }}"
          observer.vendor: OGO Security
          observer.product: Web Application Firewall
          destination.domain: "{{ parser.message.requestHeaders.site }}"
          client.geo.location: >-
            {"lat": {{ parser.message.geoIp.latitude }}, "lon": {{
            parser.message.geoIp.longitude }}}
          client.geo.city_name: "{{ parser.message.geoIp.cityName }}"
          http.request.method: "{{ parser.message.requestHeaders.method or parser.message.requestInfo.method }}"
          http.version: "{{ parser.message.requestInfo.protocol.replace('HTTP/', '') }}"
          http.request.referrer: "{{ parser.message.requestHeaders.referer }}"
          http.response.status_code: "{{ parser.message.responseCode }}"
          user_agent.name: "{{ parser.message.userAgentName }}"
          user_agent.original: "{{ parser.message.requestHeaders.get('user-agent') }}"

      # Otherwise, "0" values will be ignored
      - set:
          http.response.body.bytes: "{{ parser.message.responseHeaders.get('content-length') |int }}"
        filter: "{{ parser.message.responseHeaders.get('content-length') | int(-1) > -1 }}"

      - set:
          http.request.body.bytes: "{{ parser.message.requestInfo.get('content-size') | int }}"
        filter: "{{ parser.message.requestInfo.get('content-size') | int(-1) > -1 }}"

  set_ogo_fields:
    actions:
      - set:
          ogo.site: "{{ parser.message.site }}"
          ogo.blocked: "{{ parser.message.ogo.blocked }}"
          ogo.auditMode: "{{ parser.message.ogo.dryRun }}"
          ogo.drive.uid: "{{ parser.message.ogo.driveUid }}"
          ogo.geoblocked: "{{ parser.message.ogo.geoBlocked }}"
          ogo.credibility: "{{ parser.message.ogo.credibility }}"
          ogo.drive.label: "{{ parser.message.ogo.driveLabel }}"
          ogo.appliedAction: "{{ parser.message.ogo.appliedAction }}"
          ogo.whitelistedIp: "{{ parser.message.ogo.whitelistedIp }}"
          ogo.request.headers: "{{ parser.message.requestHeaders }}"
          ogo.response.headers: "{{ parser.message.responseHeaders }}"
          ogo.request.x_forwarded_for: "{{ parser.message.requestHeaders.get('x-forwarded-for') }}"
